using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace ScrollStitch.V20200707.Imaging.FontExtraction
{
    using V20200707.Collections.Specialized;
    using Data;
    using Imaging;
    using Imaging.Hash2D;

    /// <summary>
    /// Analyzes the screeenshot of a text template (generated by <see cref="SpacedCharArrayInfo"/>
    /// passed into a <see cref="Text.CharArrayFormatter"/>) and locates the bounding rectangles of
    /// each fixed width character.
    /// 
    /// <para>
    /// This class is only designed for font extraction from a predefined text template. It is 
    /// incapable of handling general text images.
    /// </para>
    /// </summary>
    public class FixedWidthFontRectExtractor
    {
        public const int MinCharWidth = 5;
        public const int MinCharHeight = 5;

        /// <summary>
        /// The ASCII text formatter used to specify the layout of the character table.
        /// 
        /// <para>
        /// This formatter must match the format of the text contained in the screenshot 
        /// that is to be processed by this class.
        /// </para>
        /// 
        /// <para>
        /// This class does not use <see cref="SpacedCharArrayInfo"/> because the algorithm
        /// is insensitive to image rows and columns that are completely blank. In other words,
        /// the algorithm does not count those toward its detected number of character rows 
        /// and columns.
        /// </para>
        /// </summary>
        public DuplexCharArrayInfo DuplexInfo { get; }

        /// <summary>
        /// A cropped screenshot of the image containing the ASCII character table.
        /// 
        /// <para>
        /// This screenshot must contain the ASCII character table that is formatted 
        /// by the <see cref="AsciiFontTableFormatter"/>.
        /// </para>
        /// </summary>
        public IntBitmap CharTableBitmap { get; }

        /// <summary>
        /// The size of the screenshot bitmap. This is an automatic property.
        /// </summary>
        public Size BitmapSize => CharTableBitmap.Size;

        /// <summary>
        /// The first stage Hash2D bitmap computed from the screenshot.
        /// 
        /// <para>
        /// This hash output is computed without knowing the correct font width and height.
        /// </para>
        /// </summary>
        public IntBitmap HashBitmap { get; private set; }

        /// <summary>
        /// The estimated horizontal and vertical pitch of a single fixed-width char.
        /// 
        /// <para>
        /// The pitch is the repetition interval. It is different from the crop size
        /// of the char because some chars may protude beyond its grid cell causing 
        /// overlaps.
        /// </para>
        /// </summary>
        public Size CharPitch { get; private set; }

        /// <summary>
        /// The histogram of color values on <see cref="CharTableBitmap"/>.
        /// </summary>
        public IHistogram<int, int> ColorHistogram { get; private set; }

        /// <summary>
        /// The background color of <see cref="CharTableBitmap"/>.
        /// 
        /// <para>
        /// By definition, this is the color that occurs most frequently on the input bitmap.
        /// See <see cref="ColorHistogram"/>.
        /// </para>
        /// </summary>
        public int BackgroundColor { get; private set; }

        /// <summary>
        /// Ranges of pixel Y coordinates on the <see cref="CharTableBitmap"/> which contain
        /// color pixels (non-background pixel values).
        /// </summary>
        public List<Range> ColoredRowRanges { get; private set; }

        /// <summary>
        /// Ranges of pixel X coordinates on the <see cref="CharTableBitmap"/> which contain
        /// color pixels (non-background pixel values).
        /// </summary>
        public List<Range> ColoredColumnRanges { get; private set; }

        /// <summary>
        /// A 2D array of character crop rects, trimmed.
        /// 
        /// <para>
        /// Each rect is trimmed to remove any margins that consist of solely background pixels. <br/>
        /// If the corresponding grid area is empty (not having any colored pixels), 
        /// an empty <c>Rect</c> will be stored.
        /// </para>
        /// 
        /// <para>
        /// The number of array rows is equal to <c>ColoredRowRanges.Count</c>. <br/>
        /// The number of array columns is equal to <c>ColoredColumnRanges.Count</c>.
        /// </para>
        /// </summary>
        /// 
        public Rect[,] TrimmedCharCropRects { get; private set; }

        /// <summary>
        /// A 2D array of character crop rects. With the exception of empty rects, all rects are of 
        /// identical size and aligned to each other.
        /// 
        /// <para>
        /// All non-empty rects have the size of <see cref="UniformCharCropSize"/>.
        /// </para>
        /// 
        /// <para>
        /// The number of array rows is equal to <c>ColoredRowRanges.Count</c>. <br/>
        /// The number of array columns is equal to <c>ColoredColumnRanges.Count</c>.
        /// </para>
        /// </summary>
        /// 
        public Rect[,] UniformCharCropRects { get; private set; }

        /// <summary>
        /// The size of all non-empty rectangles stored in <see cref="UniformCharCropRects"/>.
        /// 
        /// <para>
        /// The crop size is the width and height of the rectangular pixel area that 
        /// must be copied from the char table image. This size may be larger than
        /// the <see cref="CharPitch"/> due to some chars containing colored pixels
        /// that protude beyond its grid cell.
        /// </para>
        /// </summary>
        public Size UniformCharCropSize { get; private set; }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// 
        /// <param name="duplexInfo">
        /// </param>
        /// <param name="charTableBitmap">
        /// </param>
        ///
        public FixedWidthFontRectExtractor(DuplexCharArrayInfo duplexInfo, IntBitmap charTableBitmap)
        {
            if (duplexInfo is null)
            {
                throw new ArgumentNullException(nameof(duplexInfo));
            }
            if (charTableBitmap is null)
            {
                throw new ArgumentNullException(nameof(charTableBitmap));
            }
            DuplexInfo = duplexInfo;
            CharTableBitmap = charTableBitmap;
        }

        /// <summary>
        /// Performs the image parsing.
        /// </summary>
        public void Process()
        {
            _ComputeColorHistogram();
            HashBitmap = _ComputeHashBitmap();
            _EstimateCharPitch(_ComputeSortedHashPoints(HashBitmap));
            _ComputeColoredRanges();
            _VerifyCharRowColumnCounts();
            _ComputeTrimmedCharCropRects();
            _ComputeUniformCharCropRects();
        }

        private void _ComputeColorHistogram()
        {
            ColorHistogram = HistogramUtility.CreateIntHistogram<int>();
            if (CharTableBitmap.Size != BitmapSize)
            {
                throw new Exception(); // impossible
            }
            int width = BitmapSize.Width;
            int height = BitmapSize.Height;
            for (int y = 0; y < height; ++y)
            {
                for (int x = 0; x < width; ++x)
                {
                    var point = new Point(x, y);
                    int color = CharTableBitmap[point];
                    ColorHistogram.Add(color);
                }
            }
            var peaks = ColorHistogram.GetPeaks();
            if (peaks.Count != 1)
            {
                throw new Exception("Ambiguous, unable to process.");
            }
            BackgroundColor = peaks[0].Key;
        }

        private IntBitmap _ComputeHashBitmap()
        {
            int fillValue = BackgroundColor;
            Hash2DProcessor hdp = new Hash2DProcessor();
            hdp.AddStage(Direction.Vertical, windowSize: MinCharHeight, skipStep: 1, fillValue: fillValue);
            hdp.AddStage(Direction.Horizontal, windowSize: MinCharWidth, skipStep: 1, fillValue: fillValue);
            return hdp.Process(CharTableBitmap);
        }

        private List<HashPoint> _ComputeSortedHashPoints(IntBitmap hashBitmap)
        {
            if (hashBitmap.Size != BitmapSize)
            {
                throw new Exception(); // impossible
            }
            int width = BitmapSize.Width;
            int height = BitmapSize.Height;
            int pixelCount = width * height;
            var hashPoints = new List<HashPoint>(capacity: pixelCount);
            for (int y = 0; y < height; ++y)
            {
                for (int x = 0; x < width; ++x)
                {
                    var point = new Point(x, y);
                    var hashValue = hashBitmap[point];
                    hashPoints.Add(new HashPoint(hashValue, point));
                }
            }
            hashPoints.Sort(_CompareHashPoints);
            if (hashPoints.Count != pixelCount)
            {
                throw new Exception(); // impossible
            }
            return hashPoints;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int _CompareHashPoints(HashPoint a, HashPoint b)
        {
            int ax = a.X;
            int ay = a.Y;
            int ah = a.HashValue;
            int bx = b.X;
            int by = b.Y;
            int bh = b.HashValue;
            if (ah > bh) return 1;
            if (ah < bh) return -1;
            if (ay > by) return 1;
            if (ay < by) return -1;
            if (ax > bx) return 1;
            if (ax < bx) return -1;
            return 0;
        }

        private void _EstimateCharPitch(List<HashPoint> sortedHashPoints)
        {
            IHistogram<Movement, int> horzMovementHist = HistogramUtility.CreateIntHistogram<Movement>();
            int hashPointCount = sortedHashPoints.Count;
            int nextGroupStart = 0;
            while (nextGroupStart < hashPointCount)
            {
                int groupStart = nextGroupStart;
                var groupStartHP = sortedHashPoints[groupStart];
                int groupStop = groupStart + 1;
                while (groupStop < hashPointCount)
                {
                    if (sortedHashPoints[groupStop].HashValue != groupStartHP.HashValue)
                    {
                        break;
                    }
                    ++groupStop;
                }
                nextGroupStart = groupStop;
                int totalRepeatCount = groupStop - groupStart;
                if (totalRepeatCount == 2)
                {
                    var hp1 = sortedHashPoints[groupStart];
                    var hp2 = sortedHashPoints[groupStart + 1];
                    horzMovementHist.Add(hp2.Point - hp1.Point);
                }
            }
            var histPeakSet = horzMovementHist.GetPeaks();
            if (histPeakSet.Count != 1)
            {
                throw new Exception("Ambiguous, unable to process.");
            }
            var peakMovement = histPeakSet[0].Key;
            CharPitch = new Size(peakMovement.DeltaX, peakMovement.DeltaY);
        }

        private void _ComputeColoredRanges()
        {
            Rect wholeRect = new Rect(Point.Origin, BitmapSize);
            int[] rowColoredCounts;
            int[] columnColoredCounts;
            _RowColumnColoredCounts(CharTableBitmap, wholeRect, out rowColoredCounts, out columnColoredCounts);
            ColoredColumnRanges = _FindNonZeroRanges(columnColoredCounts);
            ColoredRowRanges = _FindNonZeroRanges(rowColoredCounts);
        }

        private void _RowColumnColoredCounts(IntBitmap bitmap, Rect rect, out int[] rowColoredCounts, out int[] columnColoredCounts)
        {
            int background = BackgroundColor;
            int rectWidth = rect.Width;
            int rectHeight = rect.Height;
            rowColoredCounts = new int[rectHeight];
            columnColoredCounts = new int[rectWidth];
            for (int dy = 0; dy < rectHeight; ++dy)
            {
                int y = rect.Y + dy;
                for (int dx = 0; dx < rectWidth; ++dx)
                {
                    int x = rect.X + dx;
                    var point = new Point(x, y);
                    var color = CharTableBitmap[point];
                    if (color != background)
                    {
                        rowColoredCounts[dy] += 1;
                        columnColoredCounts[dx] += 1;
                    }
                }
            }
        }

        private void _VerifyCharRowColumnCounts()
        {
            int charRowCount = ColoredRowRanges.Count;
            int charColumnCount = ColoredColumnRanges.Count;
            int expectedRowCount = DuplexInfo.RowCount;
            int expectedColumnCount = DuplexInfo.ColumnCount;
            if (charRowCount != expectedRowCount ||
                charColumnCount != expectedColumnCount)
            {
                throw new InvalidOperationException(
                    message: "Character rows and columns extracted from the screenshot " +
                    "do not match that of the table formatter. " +
                    $"Table formatter: (rows={expectedRowCount}, columns={expectedColumnCount}). " +
                    $"Screenshot: (rows={charRowCount}, columns={charColumnCount}).");
            }
        }

        private void _ComputeTrimmedCharCropRects()
        {
            int charRowCount = ColoredRowRanges.Count;
            int charColumnCount = ColoredColumnRanges.Count;
            TrimmedCharCropRects = new Rect[charRowCount, charColumnCount];
            int maxCharWidth = 0;
            int maxCharHeight = 0;
            for (int charRowIndex = 0; charRowIndex < charRowCount; ++charRowIndex)
            {
                var currRowRange = ColoredRowRanges[charRowIndex];
                for (int charColumnIndex = 0; charColumnIndex < charColumnCount; ++charColumnIndex)
                {
                    var currColumnRange = ColoredColumnRanges[charColumnIndex];
                    int rx = currColumnRange.Start;
                    int ry = currRowRange.Start;
                    int rw = currColumnRange.Count;
                    int rh = currRowRange.Count;
                    var initialRect = new Rect(rx, ry, rw, rh);
                    // ====== Remark ======
                    // TrimRect may return default(Rect) if all pixels are background.
                    // ======
                    var trimmedRect = _TrimRect(CharTableBitmap, initialRect);
                    TrimmedCharCropRects[charRowIndex, charColumnIndex] = trimmedRect;
                    maxCharWidth = Math.Max(maxCharWidth, trimmedRect.Width);
                    maxCharHeight = Math.Max(maxCharHeight, trimmedRect.Height);
                }
            }
        }

        private void _ComputeUniformCharCropRects()
        {
            IHistogram<int, int> moduloRowCentroidHist = HistogramUtility.CreateIntHistogram<int>();
            IHistogram<int, int> moduloColumnCentroidHist = HistogramUtility.CreateIntHistogram<int>();
            int charRowCount = ColoredRowRanges.Count;
            int charColumnCount = ColoredColumnRanges.Count;
            for (int charRowIndex = 0; charRowIndex < charRowCount; ++charRowIndex)
            {
                for (int charColumnIndex = 0; charColumnIndex < charColumnCount; ++charColumnIndex)
                {
                    var trimmedRect = TrimmedCharCropRects[charRowIndex, charColumnIndex];
                    if (!trimmedRect.IsPositive)
                    {
                        continue;
                    }
                    int centroidX = trimmedRect.X + trimmedRect.Width / 2;
                    int centroidY = trimmedRect.Y + trimmedRect.Height / 2;
                    int centroidXmod = centroidX % CharPitch.Width;
                    int centroidYmod = centroidY % CharPitch.Height;
                    moduloRowCentroidHist.Add(centroidYmod);
                    moduloColumnCentroidHist.Add(centroidXmod);
                }
            }
            int peakCentroidY = moduloRowCentroidHist.GetPeaks()[0].Key;
            int peakCentroidX = moduloColumnCentroidHist.GetPeaks()[0].Key;
            // ====== TODO ======
            // make less clunky
            // ======
            int firstAnchorY = peakCentroidY;
            while (firstAnchorY < ColoredRowRanges[0].Start)
            {
                firstAnchorY += CharPitch.Height;
            }
            int firstAnchorX = peakCentroidX;
            while (firstAnchorX < ColoredColumnRanges[0].Start)
            {
                firstAnchorX += CharPitch.Width;
            }
            int minStartX = int.MaxValue;
            int minStartY = int.MaxValue;
            int maxStopX = int.MinValue;
            int maxStopY = int.MinValue;
            for (int charRowIndex = 0; charRowIndex < charRowCount; ++charRowIndex)
            {
                int anchorY = firstAnchorY + charRowIndex * CharPitch.Height;
                for (int charColumnIndex = 0; charColumnIndex < charColumnCount; ++charColumnIndex)
                {
                    int anchorX = firstAnchorX + charColumnIndex * CharPitch.Width;
                    var trimmedRect = TrimmedCharCropRects[charRowIndex, charColumnIndex];
                    if (!trimmedRect.IsPositive)
                    {
                        continue;
                    }
                    minStartX = Math.Min(minStartX, trimmedRect.Left - anchorX);
                    minStartY = Math.Min(minStartY, trimmedRect.Top - anchorY);
                    maxStopX = Math.Max(maxStopX, trimmedRect.Right - anchorX);
                    maxStopY = Math.Max(maxStopY, trimmedRect.Bottom - anchorY);
                }
            }
            UniformCharCropSize = new Size(maxStopX - minStartX, maxStopY - minStartY);
            UniformCharCropRects = new Rect[charRowCount, charColumnCount];
            for (int charRowIndex = 0; charRowIndex < charRowCount; ++charRowIndex)
            {
                int anchorY = firstAnchorY + charRowIndex * CharPitch.Height;
                for (int charColumnIndex = 0; charColumnIndex < charColumnCount; ++charColumnIndex)
                {
                    int anchorX = firstAnchorX + charColumnIndex * CharPitch.Width;
                    var trimmedRect = TrimmedCharCropRects[charRowIndex, charColumnIndex];
                    if (!trimmedRect.IsPositive)
                    {
                        continue;
                    }
                    int uniformStartX = anchorX + minStartX;
                    int uniformStartY = anchorY + minStartY;
                    int uniformStopX = anchorX + maxStopX;
                    int uniformStopY = anchorY + maxStopY;
                    var uniformRect = new Rect(uniformStartX, uniformStartY,
                        uniformStopX - uniformStartX, uniformStopY - uniformStartY);
                    UniformCharCropRects[charRowIndex, charColumnIndex] = uniformRect;
                }
            }
        }

        /// <summary>
        /// Scans the pixels in the specified bitmap inside the specified initial rectangle.
        /// Return a trimmed rect where background pixels are trimmed.
        /// 
        /// <para>
        /// If all pixels inside the initial rectangle are background pixels, an empty rect
        /// is returned.
        /// </para>
        /// </summary>
        /// <param name="initialRect"></param>
        /// <returns></returns>
        private Rect _TrimRect(IntBitmap bitmap, Rect initialRect)
        {
            int rectWidth = initialRect.Width;
            int rectHeight = initialRect.Height;
            if (rectWidth <= 0 ||
                rectHeight <= 0)
            {
                return default;
            }
            int[] rowColoredCounts;
            int[] columnColoredCounts;
            _RowColumnColoredCounts(bitmap, initialRect, out rowColoredCounts, out columnColoredCounts);
            if (rowColoredCounts.Length != rectHeight ||
                columnColoredCounts.Length != rectWidth)
            {
                throw new Exception(); // impossible
            }
            Range trimmedRowRange = _FindTrimmedRange(rowColoredCounts);
            Range trimmedColumnRange = _FindTrimmedRange(columnColoredCounts);
            if (trimmedRowRange.IsEmpty ||
                trimmedColumnRange.IsEmpty)
            {
                return default;
            }
            int trimStartX = initialRect.X + trimmedColumnRange.Start;
            int trimStartY = initialRect.Y + trimmedRowRange.Start;
            int trimCountX = trimmedColumnRange.Count;
            int trimCountY = trimmedRowRange.Count;
            return new Rect(trimStartX, trimStartY, trimCountX, trimCountY);
        }

        /// <summary>
        /// Computes a <see cref="Range"/> covering the first and last non-zero items in the array.
        /// </summary>
        /// <param name="arr"></param>
        /// <returns></returns>
        private Range _FindTrimmedRange(int[] arr)
        {
            int length = arr.Length;
            if (length == 0)
            {
                return default;
            }
            int first = 0;
            while (first < length)
            {
                if (arr[first] != 0)
                {
                    break;
                }
                ++first;
            }
            if (first == length)
            {
                return default;
            }
            int last = length - 1;
            while (last > first)
            {
                if (arr[last] != 0)
                {
                    break;
                }
                --last;
            }
            return new Range(first, last + 1);
        }

        /// <summary>
        /// Computes a <see cref="List{T}"/> of <see cref="Range"/> containing every consecutive run 
        /// of non-zero items in the array.
        /// </summary>
        /// <param name="arr"></param>
        /// <returns></returns>
        private static List<Range> _FindNonZeroRanges(int[] arr)
        {
            int arrLength = arr.Length;
            var rangeList = new List<Range>();
            int nextStart = 0;
            while (nextStart < arrLength)
            {
                if (arr[nextStart] == 0)
                {
                    ++nextStart;
                    continue;
                }
                int start = nextStart;
                int stop = start + 1;
                while (stop < arrLength)
                {
                    if (arr[stop] == 0)
                    {
                        break;
                    }
                    ++stop;
                }
                rangeList.Add(new Range(start, stop));
                nextStart = stop;
            }
            return rangeList;
        }
    }
}
