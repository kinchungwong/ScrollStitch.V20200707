using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ScrollStitch.V20200707.Imaging.Hash2D
{
    using Data;

    /// <summary>
    /// Finds unique hash points from an IntBitmap containing values generated by Hash2D.
    /// 
    /// A unique hash point is a Hash2D value that has occurred just once on the entire bitmap.
    /// </summary>
    public class UniqueHashPointFilter
    {
        public double FilterFrac { get; }
        public int FilterRangeMin { get; }
        public int FilterRangeMax { get; }

        public ImageHashPointList UniqueHashPoints { get; private set; }

        public UniqueHashPointFilter(double filterFrac)
        {
            if (!(filterFrac >= 0.0 && filterFrac <= 1.0))
            {
                throw new ArgumentOutOfRangeException(nameof(filterFrac));
            }
            FilterFrac = filterFrac;
            FilterRangeMin = (int)Math.Round(filterFrac * int.MinValue);
            FilterRangeMax = (int)Math.Round(filterFrac * int.MaxValue);
        }

        public IReadOnlyList<HashPoint> Process(IntBitmap bitmap)
        {
            if (bitmap is null ||
                bitmap.Data is null)
            {
                throw new ArgumentNullException(nameof(bitmap));
            }
            var proc = new Processor(this, bitmap);
            var uniqueHashPoints = proc.Process().AsReadOnly();
            UniqueHashPoints = new ImageHashPointList(uniqueHashPoints);
            return uniqueHashPoints;
        }

        private class Processor
        {
            private UniqueHashPointFilter _host;
            private IntBitmap _bitmap;
            private int _width;
            private int _height;
            private Dictionary<int, int> _uniqueHashAndArrayIndex;
            private HashSet<int> _nonUniques;
            private int _filterRangeMin;
            private int _filterRangeMax;

            internal Processor(UniqueHashPointFilter host, IntBitmap bitmap)
            {
                _host = host;
                _bitmap = bitmap;
                _width = bitmap.Width;
                _height = bitmap.Height;
                _filterRangeMin = host.FilterRangeMin;
                _filterRangeMax = host.FilterRangeMax;
                _uniqueHashAndArrayIndex = new Dictionary<int, int>();
                _nonUniques = new HashSet<int>();
            }

            internal List<HashPoint> Process()
            {
                _ProcessWholeBitmapRuns();
                return _TranslateIndexToPoints();
            }

            private void _ProcessWholeBitmapRuns()
            {
                int[] data = _bitmap.Data;
                int length = data.Length;
                int nextStart = 0;
                while (nextStart < length)
                {
                    int hashValue = data[nextStart];
                    int nextStop = nextStart + 1;
                    while (nextStop < length &&
                        data[nextStop] == hashValue)
                    {
                        ++nextStop;
                    }
                    _AddHashRun_IfUnique(hashValue, nextStart, nextStop);
                    nextStart = nextStop;
                }
            }

            private void _AddHashRun_IfUnique(int hashValue, int startIndex, int stopIndex)
            {
                if (hashValue < _filterRangeMin ||
                    hashValue > _filterRangeMax)
                {
                    return;
                }
                if (_nonUniques.Contains(hashValue))
                {
                    return;
                }
                int runLength = stopIndex - startIndex;
                if (runLength > 1)
                {
                    _uniqueHashAndArrayIndex.Remove(hashValue);
                    _nonUniques.Add(hashValue);
                    return;
                }
                if (_uniqueHashAndArrayIndex.TryGetValue(hashValue, out int _))
                {
                    _uniqueHashAndArrayIndex.Remove(hashValue);
                    _nonUniques.Add(hashValue);
                    return;
                }
                _uniqueHashAndArrayIndex.Add(hashValue, startIndex);
            }

            private List<HashPoint> _TranslateIndexToPoints()
            {
                var result = new List<HashPoint>(capacity: _uniqueHashAndArrayIndex.Count);
                foreach (var kvp in _uniqueHashAndArrayIndex)
                {
                    int hashValue = kvp.Key;
                    int arrayIndex = kvp.Value;
                    int row = arrayIndex / _width;
                    int col = arrayIndex % _width;
                    result.Add(new HashPoint(hashValue, col, row));
                }
                return result;
            }
        }
    }
}
